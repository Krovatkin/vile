<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>File Browser</title>
    <link href="https://cdn.jsdelivr.net/npm/daisyui@4.4.19/dist/full.css" rel="stylesheet" type="text/css" />
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- GLightbox CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/glightbox/dist/css/glightbox.min.css">
</head>
<body class="bg-gray-100 min-h-screen p-4">
    <div class="w-full max-w-none mx-4 md:w-3/4 md:max-w-4xl md:mx-auto">
        <!-- Tab Bar -->
        <div class="flex items-center gap-2 mb-4">
            <div id="tabsContainer" class="flex gap-1 flex-wrap"></div>
            <button id="addTabBtn" class="btn btn-sm btn-circle btn-primary">+</button>
        </div>

        <!-- Original Content (unchanged) -->
        <div class="collapse collapse-arrow bg-blue-100">
            <input type="checkbox" checked />
            <div class="collapse-title text-xl font-medium">
                üìÅ <span id="currentPath">/</span>
            </div>
            <div class="collapse-content">
                <!-- Back button -->
                <div id="backButton" class="mb-2 hidden">
                    <button onclick="navigateBack()" class="btn btn-sm btn-outline">
                        ‚Üê Back
                    </button>
                </div>

                <ul class="menu bg-base-100 rounded-box p-2" id="fileList">
                    <!-- Content will be populated by WebSocket -->
                </ul>

                <!-- Loading Spinner -->
                <div id="loadingSpinner" class="flex justify-center items-center p-4 hidden">
                    <span class="loading loading-spinner loading-md text-blue-600"></span>
                    <span class="ml-2 text-sm text-gray-600">Loading files...</span>
                </div>
            </div>
        </div>
    </div>

    <!-- GLightbox JS (no dependencies!) -->
    <script src="https://cdn.jsdelivr.net/gh/mcstudios/glightbox/dist/js/glightbox.min.js"></script>

    <script>
        // Tab state management
        let tabCounter = 0;
        let activeTabId = null;
        let tabStates = new Map();

        // Tab state structure
        class TabState {
            constructor() {
                this.currentPath = '';
                this.ws = null;
                this.hasFolders = false;
                this.hasFiles = false;
                this.dividerAdded = false;
            }
        }

        // Save current global state to active tab
        function saveCurrentStateToTab() {
            if (activeTabId && tabStates.has(activeTabId)) {
                const state = tabStates.get(activeTabId);
                state.currentPath = currentPath;
                state.ws = ws;
                state.hasFolders = hasFolders;
                state.hasFiles = hasFiles;
                state.dividerAdded = dividerAdded;
            }
        }

        // Helper function to clear content and load tab state
        function clearAndLoadTabState(tabId) {
            // Clear current HTML content
            fileListElement.innerHTML = '';
            
            // Close WebSocket if open
            if (ws) {
                ws.close();
                ws = null;
            }
            
            // Get tab state
            const state = tabStates.get(tabId);
            if (state) {
                // Set global variables from tab state
                currentPath = state.currentPath;
                ws = state.ws;
                hasFolders = state.hasFolders;
                hasFiles = state.hasFiles;
                dividerAdded = state.dividerAdded;
                
                // Navigate to the folder
                navigateToFolder(currentPath);
            }
        }

        function createTab() {
            const tabId = `tab-${++tabCounter}`;
            
            // Create new state and copy current global state
            const newState = new TabState();
            newState.currentPath = currentPath;
            newState.hasFolders = hasFolders;
            newState.hasFiles = hasFiles;
            newState.dividerAdded = dividerAdded;
            // Note: don't copy ws, each tab needs its own connection
            
            tabStates.set(tabId, newState);
            
            const tabElement = document.createElement('div');
            tabElement.className = 'btn btn-sm btn-outline flex items-center gap-2';
            tabElement.id = `tab-header-${tabId}`;
            tabElement.innerHTML = `
                <span onclick="switchToTab('${tabId}')" class="cursor-pointer">Tab ${tabCounter}</span>
                <button onclick="closeTab('${tabId}'); event.stopPropagation();" class="btn btn-xs btn-circle btn-ghost">√ó</button>
            `;
            
            document.getElementById('tabsContainer').appendChild(tabElement);
            switchToTab(tabId);
            return tabId;
        }

        function switchToTab(tabId) {
            // Save current state to the currently active tab
            saveCurrentStateToTab();
            
            // Deactivate all tabs
            document.querySelectorAll('#tabsContainer .btn').forEach(el => {
                el.classList.remove('btn-active');
                el.classList.add('btn-outline');
            });
            
            // Activate selected tab
            const tabHeader = document.getElementById(`tab-header-${tabId}`);
            if (tabHeader) {
                tabHeader.classList.add('btn-active');
                tabHeader.classList.remove('btn-outline');
                activeTabId = tabId;
                
                // Clear and load the new tab state
                clearAndLoadTabState(tabId);
            }
        }

        function closeTab(tabId) {
            // Don't close if it's the last tab
            if (tabStates.size <= 1) {
                return;
            }
            
            const tabHeader = document.getElementById(`tab-header-${tabId}`);
            if (tabHeader) {
                tabHeader.remove();
            }
            
            // Close WebSocket if it exists
            const state = tabStates.get(tabId);
            if (state && state.ws) {
                state.ws.close();
            }
            
            // Remove state
            tabStates.delete(tabId);
            
            // If this was the active tab, switch to another
            if (activeTabId === tabId) {
                const remainingTabs = document.querySelectorAll('#tabsContainer .btn');
                if (remainingTabs.length > 0) {
                    const firstTabId = remainingTabs[0].id.replace('tab-header-', '');
                    switchToTab(firstTabId);
                }
            }
        }

        function addNewTab() {
            createTab();
        }

        // Original code (completely unchanged)
        let lightbox;

        // Check if file is an image
        function isImageFile(filename) {
            const imageExtensions = ['.jpg', '.jpeg', '.png'];
            const ext = filename.toLowerCase().substring(filename.lastIndexOf('.'));
            return imageExtensions.includes(ext);
        }

        // Get appropriate icon for file type
        function getFileIcon(filename) {
            if (isImageFile(filename)) {
                return `
                    <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                        <path fill-rule="evenodd" d="M4 3a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V5a2 2 0 00-2-2H4zm12 12H4l4-8 3 6 2-4 3 6z" clip-rule="evenodd"></path>
                    </svg>
                `;
            } else {
                return `
                    <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                        <path fill-rule="evenodd" d="M4 4a2 2 0 012-2h4.586A2 2 0 0112 2.586L15.414 6A2 2 0 0116 7.414V16a2 2 0 01-2 2H6a2 2 0 01-2-2V4zm2 6a1 1 0 011-1h6a1 1 0 110 2H7a1 1 0 01-1-1zm1 3a1 1 0 100 2h6a1 1 0 100-2H7z" clip-rule="evenodd"></path>
                    </svg>
                `;
            }
        }

        // Reinitialize lightbox after adding new images
        function reinitializeLightbox() {
            if (lightbox) {
                lightbox.destroy();
            }
            lightbox = GLightbox({
                selector: '.glightbox',
                touchNavigation: true,
                loop: true,
                autoplayVideos: false
            });
        }

        // Templates
        const folderTemplate = (name, path) => `
            <li>
                <a href="#" onclick="navigateToFolder('${path.replace(/'/g, "\\'")}'); return false;" class="text-yellow-600 hover:bg-yellow-50">
                    <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                        <path d="M2 6a2 2 0 012-2h5l2 2h5a2 2 0 012 2v6a2 2 0 01-2 2H4a2 2 0 01-2-2V6z"></path>
                    </svg>
                    ${name}
                </a>
            </li>
        `;

        const fileTemplate = (name, path) => {
            const isImage = isImageFile(name);
            const colorClass = isImage ? 'text-green-600 hover:bg-green-50' : 'text-blue-600 hover:bg-blue-50';
            const icon = getFileIcon(name);

            if (isImage) {
                    const imageUrl = `/image/${path}`;
                return `
                    <li>
                        <a href="${imageUrl}" class="glightbox ${colorClass}" data-gallery="gallery" data-title="${name}">
                            ${icon}
                            ${name} üñºÔ∏è 
                        </a>
                    </li>
                `;
            } else {
                return `
                    <li>
                        <a href="#" class="${colorClass}">
                            ${icon}
                            ${name}
                        </a>
                    </li>
                `;
            }
        };

        const dividerTemplate = () => `<div class="divider my-1"></div>`;

        // Global variables (start with defaults)
        let ws = null;
        let currentPath = '';
        let hasFolders = false;
        let hasFiles = false;
        let dividerAdded = false;

        // DOM elements
        const fileListElement = document.getElementById('fileList');
        const spinnerElement = document.getElementById('loadingSpinner');
        const currentPathElement = document.getElementById('currentPath');
        const backButtonElement = document.getElementById('backButton');

        // Show/hide spinner
        function showSpinner() {
            spinnerElement.classList.remove('hidden');
        }

        function hideSpinner() {
            spinnerElement.classList.add('hidden');
            // Reinitialize lightbox when loading is complete
            setTimeout(reinitializeLightbox, 100);
        }

        // Update back button visibility
        function updateBackButton() {
            if (currentPath === '') {
                backButtonElement.classList.add('hidden');
            } else {
                backButtonElement.classList.remove('hidden');
            }
        }

        // Clear file list and reset state
        function clearFileList() {
            fileListElement.innerHTML = '';
            hasFolders = false;
            hasFiles = false;
            dividerAdded = false;
        }

        // Append HTML immediately to the file list
        function appendToFileList(html) {
            fileListElement.insertAdjacentHTML('beforeend', html);
        }

        // Add divider between folders and files if needed
        function addDividerIfNeeded() {
            if (hasFolders && hasFiles && !dividerAdded) {
                appendToFileList(dividerTemplate());
                dividerAdded = true;
            }
        }

        // Handle incoming WebSocket messages
        function handleMessage(event) {
            try {
                const data = JSON.parse(event.data);
                console.log('Received:', data);

                // If empty array, hide spinner and stop
                if (Array.isArray(data) && data.length === 0) {
                    hideSpinner();
                    return;
                }

                // Show spinner when we start receiving data
                if (Array.isArray(data) && data.length > 0) {
                    showSpinner();
                }

                // Process each item in the array and append immediately
                data.forEach(item => {
                    if (item.type === 'folder') {
                        if (!hasFolders) {
                            hasFolders = true;
                        }
                        appendToFileList(folderTemplate(item.name, item.path));
                    } else if (item.type === 'file') {
                        if (!hasFiles) {
                            hasFiles = true;
                            addDividerIfNeeded();
                        }
                        appendToFileList(fileTemplate(item.name, item.path));
                    }
                });

            } catch (error) {
                console.error('Error parsing WebSocket message:', error);
            }
        }

        // Connect to WebSocket
        function connectWebSocket(path) {
            if (ws) {
                ws.close();
            }

            clearFileList();
            showSpinner();

            currentPath = path;
            // Display path with leading slash for UI
            const displayPath = path === '' ? '/' : '/' + path;
            currentPathElement.textContent = displayPath;
            updateBackButton();

            // Use current domain and port instead of hardcoded localhost
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/files?path=${encodeURIComponent(path)}`;

            ws = new WebSocket(wsUrl);

            ws.onopen = function(event) {
                console.log('WebSocket connected for path:', path);
            };

            ws.onmessage = handleMessage;

            ws.onclose = function(event) {
                console.log('WebSocket disconnected');
                hideSpinner();
            };

            ws.onerror = function(error) {
                console.error('WebSocket error:', error);
                hideSpinner();
            };
        }

        // Navigate to folder - use the path from server response directly
        function navigateToFolder(folderPath) {
            connectWebSocket(folderPath);
        }

        // Navigate back to parent directory
        function navigateBack() {
            if (currentPath === '') return; // Already at root

            // Get parent path by removing the last segment
            const pathParts = currentPath.split('/');
            pathParts.pop(); // Remove last part
            const parentPath = pathParts.join('/');

            connectWebSocket(parentPath);
        }

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize lightbox
            reinitializeLightbox();

            // Add event listener for new tab button
            document.getElementById('addTabBtn').addEventListener('click', addNewTab);

            // Create first tab (will use default global state)
            createTab();
        });
    </script>
</body>
</html>


